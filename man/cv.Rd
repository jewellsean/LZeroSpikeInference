% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv.R
\name{cv}
\alias{cv}
\title{Cross-validate and optimize model parameters
See Algorithm 3 of Jewell and Witten (2017)
Exact Spike Train Inference Via L0 Optimization}
\usage{
cv(dat, params, type = "ar1", optimizeParams = TRUE, nLambdas = 10,
  lambdas = NULL)
}
\arguments{
\item{dat}{fluorescence trace (a vector)}

\item{params}{model parameters. For the AR(1) and AR(1) intercept models this is the scalar decay parameter; this is a
dataframe with two parameters gammaC and gammaD for the difference of exponentials model. That is,
\code{params <- data.frame(gammaC = 0.98, gammaD = 0.818)}, for the difference of exponentials model.}

\item{type}{type of model, must be one of AR(1) 'ar1', AR(1) with intercept 'intercept', or difference of exponentials 'dexp'}

\item{optimizeParams}{whether the model parameters should be optimized (TRUE) or just CV of the tuning parameter (FALSE)}

\item{nLambdas}{number of tuning parameters to estimate the model (grid of values is automatically produced)}

\item{lambdas}{vector of tuning parameters to use in cross-validation}
}
\value{
A list of values corresponding to the 2-fold cross-validation:

\code{cvError} the MSE for each tuning parameter

\code{cvSE} the SE for the MSE for each tuning parameter

\code{lambdas} tuning parameters

\code{params} matrix of (optimized) parameters, rows correspond to tuning parameters, columns correspond to optimized parameter

\code{lambdaMin} tuning parameter that gives the smallest MSE

\code{lamnda1SE} 1 SE tuning parameter

\code{indexMin} the index corresponding to lambdaMin

\code{index1SE} the index corresponding to lambda1SE
}
\description{
Cross-validate and optimize model parameters
See Algorithm 3 of Jewell and Witten (2017)
Exact Spike Train Inference Via L0 Optimization
}
\examples{

sampleData <- simulateAR1(n = 500, seed = 1, poisRate = 0.01, decay = 0.998, sd = 0.15)

# AR(1) model
# Select tuning parameter with 1 SE rule
cvOut <- cv(sampleData$fl, params = 0.998, type = "ar1", optimizeParams = FALSE)
plotCV(cvOut)
fit <- segment(sampleData$fl, params = 0.998, penalty = cvOut$lambda1SE, type = "ar1")
plotSegmentation(fit, trueSpikes = sampleData$spikes)

# AR(1) model
# Select tuning parameter with 1 SE rule, provide tuning parameters
cvOut <- cv(sampleData$fl, params = 0.998, type = "ar1", optimizeParams = FALSE,
lambdas = 10^seq(-1, 2, length.out = 10))
plotCV(cvOut)
fit <- segment(sampleData$fl, params = 0.998, penalty = cvOut$lambda1SE, type = "ar1")
plotSegmentation(fit, trueSpikes = sampleData$spikes)

# AR(1) model
# Select tuning parameter with 1 SE rule and optimize decay parameter
cvOut <- cv(sampleData$fl, params = 0.998, type = "ar1", optimizeParams = TRUE)
plotCV(cvOut)
fit <- segment(sampleData$fl, params = cvOut$params[cvOut$index1SE, 1],
penalty = cvOut$lambda1SE, type = "ar1")
plotSegmentation(fit, trueSpikes = sampleData$spikes)

# AR(1) + intercept model
# Select tuning parameter with 1 SE rule and optimize decay parameter
cvOut <- cv(sampleData$fl, params = 0.998, type = "intercept", optimizeParams = TRUE)
plotCV(cvOut)
fit <- segment(sampleData$fl, params = cvOut$params[cvOut$index1SE, 1],
penalty = cvOut$lambda1SE, type = "ar1")
plotSegmentation(fit, trueSpikes = sampleData$spikes)

# Difference of exponentials model
# Select tuning parameter with 1 SE rule and optimize both model parameters
params <- data.frame(gammaC = 0.998, gammaD = 0.818)
cvOut <- cv(sampleData$fl, params = params, type = "dexp", optimizeParams = TRUE)
plotCV(cvOut)
optimParams <- data.frame(t(cvOut$params[cvOut$index1SE, ]))
fit <- segment(sampleData$fl, params = optimParams, penalty = cvOut$lambda1SE, type = "dexp")
plotSegmentation(fit, trueSpikes = sampleData$spikes)


}
